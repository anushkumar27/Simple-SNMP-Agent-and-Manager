/*							-- DO NOT EDIT --
 * This IDL file has been generated by smidump version 0.4.8:
 *   smidump -f corba MAU-MIB
 *
 * Derived from MAU-MIB:
 *   Management information for 802.3 MAUs.
 *   
 *   The following reference is used throughout this MIB module:
 *   
 *   [IEEE802.3] refers to:
 *      IEEE Std 802.3, 2005 Edition: 'IEEE Standard for Information
 *      technology - Telecommunications and information exchange
 *      between systems - Local and metropolitan area networks -
 *      Specific requirements - Part 3: Carrier sense multiple
 *      access with collision detection (CSMA/CD) access method and
 *      physical layer specifications'.
 *   
 *      Of particular interest is Clause 30, 'Management'.
 *   
 *   Copyright (C) The IETF Trust (2007).
 *   This version of this MIB module is part of RFC 4836;
 *   see the RFC itself for full legal notices.
 *
 * Revision 2007-04-21 00:00:
 *   Updated to reference IANA maintaned textual
 *   conventions for MAU types, Media Availability state,
 *   Auto Negotiation capabilities, and jack types,
 *   instead of using internally defined values.
 *   
 *   This version is published as RFC 4836.
 *
 * Revision 2003-09-19 00:00:
 *   Updated to include support for 10 Gb/s MAUs.
 *   This resulted in the following revisions:
 *   - Added OBJECT-IDENTITY definitions for
 *     10 gigabit MAU types
 *   
 *   
 *   
 *   - Added fiberLC jack type to JackType TC
 *   - Extended ifMauTypeListBits with bits for
 *     the 10 gigabit MAU types
 *   - Added enumerations to ifMauMediaAvailable,
 *     and updated its DESCRIPTION to reflect
 *     behaviour at 10 Gb/s
 *   - Added 64-bit version of ifMauFalseCarriers
 *     and added mauIfGrpHCStats object group to
 *     contain the new object
 *   - Deprecated mauModIfCompl2 and replaced it
 *     with mauModIfCompl3, which includes the new
 *     object group
 *   
 *    This version published as RFC 3636.
 *
 * Revision 1999-08-24 04:00:
 *   This version published as RFC 2668.  Updated
 *   to include support for 1000 Mb/sec
 *   MAUs and flow control negotiation.
 *
 * Revision 1997-10-31 00:00:
 *   Version published as RFC 2239.
 *
 * Revision 1993-09-30 00:00:
 *   Initial version, published as RFC 1515.
 *
 * $Id: MAU_MIB.idl 1771 2012-03-30 11:43:34Z schoenw $
 */

#ifndef _MAU_MIB_IDL_
#define _MAU_MIB_IDL_

#include <ASN1Types.idl>
#include <SNMPMgmt.idl>
#include <IANA_MAU_MIB.idl>
#include <IF_MIB.idl>
#include <SNMPv2_SMI.idl>
#include <SNMPv2_TC.idl>

module MAU_MIB {

    typedef IANA_MAU_MIB::IANAifJackTypeType IANAifJackTypeType;
    typedef IANA_MAU_MIB::IANAifMauAutoNegCapBitsType IANAifMauAutoNegCapBitsType;
    typedef IANA_MAU_MIB::IANAifMauMediaAvailableType IANAifMauMediaAvailableType;
    typedef IANA_MAU_MIB::IANAifMauTypeListBitsType IANAifMauTypeListBitsType;
    typedef IF_MIB::InterfaceIndexType InterfaceIndexType;
    typedef SNMPv2_SMI::Counter32Type Counter32Type;
    typedef SNMPv2_SMI::Counter64Type Counter64Type;
    typedef SNMPv2_SMI::Integer32Type Integer32Type;
    typedef SNMPv2_TC::AutonomousTypeType AutonomousTypeType;
    typedef SNMPv2_TC::TruthValueType TruthValueType;

    const string moduleIdentity = "mauMod";
    const ASN1_ObjectIdentifier mauMod = "::MAU_MIB::mauMod";

    /*
             Management information for 802.3 MAUs.
             
             The following reference is used throughout this MIB module:
             
             [IEEE802.3] refers to:
                IEEE Std 802.3, 2005 Edition: 'IEEE Standard for Information
                technology - Telecommunications and information exchange
                between systems - Local and metropolitan area networks -
                Specific requirements - Part 3: Carrier sense multiple
                access with collision detection (CSMA/CD) access method and
                physical layer specifications'.
             
                Of particular interest is Clause 30, 'Management'.
             
             Copyright (C) The IETF Trust (2007).
             This version of this MIB module is part of RFC 4836;
             see the RFC itself for full legal notices.

    LAST-UPDATED:   200704210000Z

    ORGANIZATION:
            "IETF Ethernet Interfaces and Hub MIB Working Group"

    CONTACT-INFO:
            "WG charter:
             http://www.ietf.org/html.charters/hubmib-charter.html
             
             Mailing Lists:
             General Discussion: hubmib@ietf.org
             To Subscribe: hubmib-request@ietf.org
             In Body: subscribe your_email_address
             
             
             
             Chair: Bert Wijnen
             Postal: Alcatel-Lucent
                   Schagen 33
                   3461 GL Linschoten
                   Netherlands
             Phone: +31-348-407-775
             EMail: bwijnen@alcatel-lucent.com
             
             Editor: Edward Beili
             Postal: Actelis Networks Inc.
                   25 Bazel St., P.O.B. 10173
                   Petach-Tikva 10173
                   Israel
              Tel: +972-3-924-3491
             EMail: edward.beili@actelis.com"

    REVISION:       "200704210000Z"
    REVISION-DESCRIPTION:
            "Updated to reference IANA maintaned textual
             conventions for MAU types, Media Availability state,
             Auto Negotiation capabilities, and jack types,
             instead of using internally defined values.
             
             This version is published as RFC 4836."

    REVISION:       "200309190000Z"
    REVISION-DESCRIPTION:
            "Updated to include support for 10 Gb/s MAUs.
             This resulted in the following revisions:
             - Added OBJECT-IDENTITY definitions for
               10 gigabit MAU types
             
             
             
             - Added fiberLC jack type to JackType TC
             - Extended ifMauTypeListBits with bits for
               the 10 gigabit MAU types
             - Added enumerations to ifMauMediaAvailable,
               and updated its DESCRIPTION to reflect
               behaviour at 10 Gb/s
             - Added 64-bit version of ifMauFalseCarriers
               and added mauIfGrpHCStats object group to
               contain the new object
             - Deprecated mauModIfCompl2 and replaced it
               with mauModIfCompl3, which includes the new
               object group
             
              This version published as RFC 3636."

    REVISION:       "199908240400Z"
    REVISION-DESCRIPTION:
            "This version published as RFC 2668.  Updated
             to include support for 1000 Mb/sec
             MAUs and flow control negotiation."

    REVISION:       "199710310000Z"
    REVISION-DESCRIPTION:
            "Version published as RFC 2239."

    REVISION:       "199309300000Z"
    REVISION-DESCRIPTION:
            "Initial version, published as RFC 1515."

    */

    typedef ASN1_Integer RpMauGroupIndexType; 

    typedef ASN1_Integer RpMauPortIndexType; 

    typedef ASN1_Integer RpMauIndexType; 

    typedef ASN1_Integer RpMauStatusType; 
    const RpMauStatusType RpMauStatusType_other = 1;
    const RpMauStatusType RpMauStatusType_unknown = 2;
    const RpMauStatusType RpMauStatusType_operational = 3;
    const RpMauStatusType RpMauStatusType_standby = 4;
    const RpMauStatusType RpMauStatusType_shutdown = 5;
    const RpMauStatusType RpMauStatusType_reset = 6;
    const string RpMauStatusType_NameNumberList = "other (1) , unknown (2) , operational (3) , standby (4) , shutdown (5) , reset (6)";

    typedef ASN1_Integer RpMauJabberStateType; 
    const RpMauJabberStateType RpMauJabberStateType_other = 1;
    const RpMauJabberStateType RpMauJabberStateType_unknown = 2;
    const RpMauJabberStateType RpMauJabberStateType_noJabber = 3;
    const RpMauJabberStateType RpMauJabberStateType_jabbering = 4;
    const string RpMauJabberStateType_NameNumberList = "other (1) , unknown (2) , noJabber (3) , jabbering (4)";

    typedef ASN1_Integer RpJackIndexType; 

    typedef ASN1_Integer IfMauIndexType; 

    typedef ASN1_Integer IfMauStatusType; 
    const IfMauStatusType IfMauStatusType_other = 1;
    const IfMauStatusType IfMauStatusType_unknown = 2;
    const IfMauStatusType IfMauStatusType_operational = 3;
    const IfMauStatusType IfMauStatusType_standby = 4;
    const IfMauStatusType IfMauStatusType_shutdown = 5;
    const IfMauStatusType IfMauStatusType_reset = 6;
    const string IfMauStatusType_NameNumberList = "other (1) , unknown (2) , operational (3) , standby (4) , shutdown (5) , reset (6)";

    typedef ASN1_Integer IfMauJabberStateType; 
    const IfMauJabberStateType IfMauJabberStateType_other = 1;
    const IfMauJabberStateType IfMauJabberStateType_unknown = 2;
    const IfMauJabberStateType IfMauJabberStateType_noJabber = 3;
    const IfMauJabberStateType IfMauJabberStateType_jabbering = 4;
    const string IfMauJabberStateType_NameNumberList = "other (1) , unknown (2) , noJabber (3) , jabbering (4)";

    typedef ASN1_Integer IfJackIndexType; 

    typedef ASN1_Integer IfMauAutoNegAdminStatusType; 
    const IfMauAutoNegAdminStatusType IfMauAutoNegAdminStatusType_enabled = 1;
    const IfMauAutoNegAdminStatusType IfMauAutoNegAdminStatusType_disabled = 2;
    const string IfMauAutoNegAdminStatusType_NameNumberList = "enabled (1) , disabled (2)";

    typedef ASN1_Integer IfMauAutoNegRemoteSignalingType; 
    const IfMauAutoNegRemoteSignalingType IfMauAutoNegRemoteSignalingType_detected = 1;
    const IfMauAutoNegRemoteSignalingType IfMauAutoNegRemoteSignalingType_notdetected = 2;
    const string IfMauAutoNegRemoteSignalingType_NameNumberList = "detected (1) , notdetected (2)";

    typedef ASN1_Integer IfMauAutoNegConfigType; 
    const IfMauAutoNegConfigType IfMauAutoNegConfigType_other = 1;
    const IfMauAutoNegConfigType IfMauAutoNegConfigType_configuring = 2;
    const IfMauAutoNegConfigType IfMauAutoNegConfigType_complete = 3;
    const IfMauAutoNegConfigType IfMauAutoNegConfigType_disabled = 4;
    const IfMauAutoNegConfigType IfMauAutoNegConfigType_parallelDetectFail = 5;
    const string IfMauAutoNegConfigType_NameNumberList = "other (1) , configuring (2) , complete (3) , disabled (4) , parallelDetectFail (5)";

    typedef ASN1_Integer IfMauAutoNegRestartType; 
    const IfMauAutoNegRestartType IfMauAutoNegRestartType_restart = 1;
    const IfMauAutoNegRestartType IfMauAutoNegRestartType_norestart = 2;
    const string IfMauAutoNegRestartType_NameNumberList = "restart (1) , norestart (2)";

    typedef ASN1_Integer IfMauAutoNegRemoteFaultAdvertisedType; 
    const IfMauAutoNegRemoteFaultAdvertisedType IfMauAutoNegRemoteFaultAdvertisedType_noError = 1;
    const IfMauAutoNegRemoteFaultAdvertisedType IfMauAutoNegRemoteFaultAdvertisedType_offline = 2;
    const IfMauAutoNegRemoteFaultAdvertisedType IfMauAutoNegRemoteFaultAdvertisedType_linkFailure = 3;
    const IfMauAutoNegRemoteFaultAdvertisedType IfMauAutoNegRemoteFaultAdvertisedType_autoNegError = 4;
    const string IfMauAutoNegRemoteFaultAdvertisedType_NameNumberList = "noError (1) , offline (2) , linkFailure (3) , autoNegError (4)";

    typedef ASN1_Integer IfMauAutoNegRemoteFaultReceivedType; 
    const IfMauAutoNegRemoteFaultReceivedType IfMauAutoNegRemoteFaultReceivedType_noError = 1;
    const IfMauAutoNegRemoteFaultReceivedType IfMauAutoNegRemoteFaultReceivedType_offline = 2;
    const IfMauAutoNegRemoteFaultReceivedType IfMauAutoNegRemoteFaultReceivedType_linkFailure = 3;
    const IfMauAutoNegRemoteFaultReceivedType IfMauAutoNegRemoteFaultReceivedType_autoNegError = 4;
    const string IfMauAutoNegRemoteFaultReceivedType_NameNumberList = "noError (1) , offline (2) , linkFailure (3) , autoNegError (4)";

    interface dot3RpMauBasicGroup : SNMPMgmt::SmiEntry {

        /*
             Table of descriptive and status information
             about the MAU(s) attached to the ports of a
             repeater.
        */
        SNMPMgmt::SmiTableIterator get_rpMauTable();

        /*
             Information about the external jacks attached
             to MAUs attached to the ports of a repeater.
        */
        SNMPMgmt::SmiTableIterator get_rpJackTable();
    };


    /*
             An entry in the table, containing information
             about a single MAU.
    */
    interface rpMauEntry : SNMPMgmt::SmiEntry {

        const string IndexVarList = "rpMauGroupIndex rpMauPortIndex rpMauIndex";

        /*
             This variable uniquely identifies the group
             containing the port to which the MAU described
             by this entry is connected.
             
             Note:  In practice, a group will generally be
             a field-replaceable unit (i.e., module, card,
             or board) that can fit in the physical system
             enclosure, and the group number will correspond
             to a number marked on the physical enclosure.
             
             The group denoted by a particular value of this
             object is the same as the group denoted by the
             same value of rptrGroupIndex.
        REFERENCE:
            "RFC 2108, rptrGroupIndex."

        */
        readonly attribute RpMauGroupIndexType rpMauGroupIndex;

        /*
             This variable uniquely identifies the repeater
             port within group rpMauGroupIndex to which the
             MAU described by this entry is connected.
        REFERENCE:
            "RFC 2108, rptrPortIndex."

        */
        readonly attribute RpMauPortIndexType rpMauPortIndex;

        /*
             This variable uniquely identifies the MAU
             described by this entry from among other
             MAUs connected to the same port
             (rpMauPortIndex).
        REFERENCE:
            "[IEEE802.3], 30.5.1.1.1, aMAUID."

        */
        readonly attribute RpMauIndexType rpMauIndex;

        /*
             This object identifies the MAU type.  Values for
             standard IEEE 802.3 MAU types are defined in the
             IANA maintained IANA-MAU-MIB module, as
             OBJECT-IDENTITIES of dot3MauType.
             If the MAU type is unknown, the object identifier
             zeroDotZero is returned.
        REFERENCE:
            "[IEEE802.3], 30.5.1.1.2, aMAUType."

        */
        readonly attribute AutonomousTypeType rpMauType;

        /*
             The current state of the MAU.  This object MAY
             be implemented as a read-only object by those
             agents and MAUs that do not implement software
             control of the MAU state.  Some agents may not
             support setting the value of this object to some
             of the enumerated values.
             
             The value other(1) is returned if the MAU is in
             a state other than one of the states 2 through
             6.
             
             
             
             The value unknown(2) is returned when the MAU's
             true state is unknown; for example, when it is
             being initialized.
             
             A MAU in the operational(3) state is fully
             functional; it operates, and passes signals to its
             attached DTE or repeater port in accordance to
             its specification.
             
             A MAU in standby(4) state forces DI and CI to
             idle, and the media transmitter to idle or fault,
             if supported.  Standby(4) mode only applies to
             link type MAUs.  The state of
             rpMauMediaAvailable is unaffected.
             
             A MAU in shutdown(5) state assumes the same
             condition on DI, CI, and the media transmitter,
             as though it were powered down or not connected.
             The MAU MAY return other(1) value for the
             rpMauJabberState and rpMauMediaAvailable objects
             when it is in this state.  For an AUI, this
             state will remove power from the AUI.
             
             Setting this variable to the value reset(6)
             resets the MAU in the same manner as a
             power-off, power-on cycle of at least one-half
             second would.  The agent is not required to
             return the value reset(6).
             
             Setting this variable to the value
             operational(3), standby(4), or shutdown(5)
             causes the MAU to assume the respective state,
             except that setting a mixing-type MAU or an AUI
             to standby(4) will cause the MAU to enter the
             shutdown state.
        REFERENCE:
            "[IEEE802.3], 30.5.1.1.7, aMAUAdminState,
             30.5.1.2.2, acMAUAdminControl, and 30.5.1.2.1,
             acResetMAU."

        */
        attribute RpMauStatusType rpMauStatus;

        /*
             This object identifies Media Available state of
             the MAU, complementary to the rpMauStatus.  Values
             for the standard IEEE 802.3 Media Available states
             are defined in the IANA maintained IANA-MAU-MIB
             
             
             
             module, as IANAifMauMediaAvailable TC.
        REFERENCE:
            "[IEEE802.3], 30.5.1.1.4, aMediaAvailable."

        */
        readonly attribute IANAifMauMediaAvailableType rpMauMediaAvailable;

        /*
             A count of the number of times that
             rpMauMediaAvailable for this MAU instance leaves
             the state available(3).
             
             Discontinuities in the value of this counter can
             occur at re-initialization of the management
             system and at other times, as indicated by the
             value of rptrMonitorPortLastChange.
        REFERENCE:
            "[IEEE802.3], 30.5.1.1.5, aLoseMediaCounter.
             RFC 2108, rptrMonitorPortLastChange"

        */
        readonly attribute Counter32Type rpMauMediaAvailableStateExits;

        /*
             The value other(1) is returned if the jabber
             state is not 2, 3, or 4.  The agent MUST always
             return other(1) for MAU type dot3MauTypeAUI.
             
             The value unknown(2) is returned when the MAU's
             true state is unknown; for example, when it is
             being initialized.
             
             If the MAU is not jabbering the agent returns
             noJabber(3).  This is the 'normal' state.
             
             If the MAU is in jabber state the agent returns
             the jabbering(4) value.
        REFERENCE:
            "[IEEE802.3], 30.5.1.1.6, aJabber.jabberFlag."

        */
        readonly attribute RpMauJabberStateType rpMauJabberState;

        /*
             A count of the number of times that
             mauJabberState for this MAU instance enters the
             state jabbering(4).  For MAUs of type
             dot3MauTypeAUI, dot3MauType100BaseT4,
             dot3MauType100BaseTX, dot3MauType100BaseFX, and
             all 1000Mbps types, this counter will always
             indicate zero.
             
             Discontinuities in the value of this counter can
             occur at re-initialization of the management
             system and at other times, as indicated by the
             value of rptrMonitorPortLastChange.
        REFERENCE:
            "[IEEE802.3], 30.5.1.1.6, aJabber.jabberCounter.
             RFC 2108, rptrMonitorPortLastChange"

        */
        readonly attribute Counter32Type rpMauJabberingStateEnters;

        /*
             A count of the number of false carrier events
             during IDLE in 100BASE-X links.  This counter
             does not increment at the symbol rate.  It can
             increment after a valid carrier completion at a
             maximum rate of once per 100 ms until the next
             carrier event.
             
             This counter increments only for MAUs of type
             dot3MauType100BaseT4, dot3MauType100BaseTX,
             dot3MauType100BaseFX, and all 1000Mbps types.
             
             For all other MAU types, this counter will
             always indicate zero.
             
             The approximate minimum time for rollover of
             this counter is 7.4 hours.
             
             Discontinuities in the value of this counter can
             occur at re-initialization of the management
             system and at other times, as indicated by the
             value of rptrMonitorPortLastChange.
        REFERENCE:
            "[IEEE802.3], 30.5.1.1.10, aFalseCarriers.
             RFC 2108, rptrMonitorPortLastChange"

        */
        readonly attribute Counter32Type rpMauFalseCarriers;
    };


    /*
             An entry in the table, containing information
             about a particular jack.
    */
    interface rpJackEntry : SNMPMgmt::SmiEntry {

        const string IndexVarList = "rpMauGroupIndex rpMauPortIndex rpMauIndex rpJackIndex";

        /*
             The jack connector type, as it appears on the
             outside of the system.
        */
        readonly attribute IANAifJackTypeType rpJackType;
    };

    interface dot3IfMauBasicGroup : SNMPMgmt::SmiEntry {

        /*
             Table of descriptive and status information
             about MAU(s) attached to an interface.
        */
        SNMPMgmt::SmiTableIterator get_ifMauTable();

        /*
             Information about the external jacks attached
             to MAUs attached to an interface.
        */
        SNMPMgmt::SmiTableIterator get_ifJackTable();
    };


    /*
             An entry in the table, containing information
             about a single MAU.
    */
    interface ifMauEntry : SNMPMgmt::SmiEntry {

        const string IndexVarList = "ifMauIfIndex ifMauIndex";

        /*
             This variable uniquely identifies the interface
             to which the MAU described by this entry is
             connected.
        REFERENCE:
            "RFC 2863, ifIndex"

        */
        readonly attribute InterfaceIndexType ifMauIfIndex;

        /*
             This variable uniquely identifies the MAU
             described by this entry from among other MAUs
             connected to the same interface (ifMauIfIndex).
        REFERENCE:
            "[IEEE802.3], 30.5.1.1.1, aMAUID."

        */
        readonly attribute IfMauIndexType ifMauIndex;

        /*
             This object identifies the MAU type.  Values for
             standard IEEE 802.3 MAU types are defined in the
             IANA maintained IANA-MAU-MIB module, as
             OBJECT-IDENTITIES of dot3MauType.
             If the MAU type is unknown, the object identifier
             zeroDotZero is returned.
             
             This object represents the operational type of
             the MAU, as determined by either 1) the result
             of the auto-negotiation function or 2) if
             auto-negotiation is not enabled or is not
             implemented for this MAU, by the value of the
             object ifMauDefaultType.  In case 2), a set to
             the object ifMauDefaultType will force the MAU
             into the new operating mode.
        REFERENCE:
            "[IEEE802.3], 30.5.1.1.2, aMAUType."

        */
        readonly attribute AutonomousTypeType ifMauType;

        /*
             The current state of the MAU.  This object MAY
             be implemented as a read-only object by those
             agents and MAUs that do not implement software
             control of the MAU state.  Some agents may not
             
             
             
             support setting the value of this object to some
             of the enumerated values.
             
             The value other(1) is returned if the MAU is in
             a state other than one of the states 2 through
             6.
             
             The value unknown(2) is returned when the MAU's
             true state is unknown; for example, when it is
             being initialized.
             
             A MAU in the operational(3) state is fully
             functional; it operates, and passes signals to its
             attached DTE or repeater port in accordance to
             its specification.
             
             A MAU in standby(4) state forces DI and CI to
             idle and the media transmitter to idle or fault,
             if supported.  Standby(4) mode only applies to
             link type MAUs.  The state of
             ifMauMediaAvailable is unaffected.
             
             A MAU in shutdown(5) state assumes the same
             condition on DI, CI, and the media transmitter,
             as though it were powered down or not connected.
             The MAU MAY return other(1) value for the
             ifMauJabberState and ifMauMediaAvailable objects
             when it is in this state.  For an AUI, this
             state will remove power from the AUI.
             
             Setting this variable to the value reset(6)
             resets the MAU in the same manner as a
             power-off, power-on cycle of at least one-half
             second would.  The agent is not required to
             return the value reset(6).
             
             Setting this variable to the value
             operational(3), standby(4), or shutdown(5)
             causes the MAU to assume the respective state,
             except that setting a mixing-type MAU or an AUI
             to standby(4) will cause the MAU to enter the
             shutdown state.
        REFERENCE:
            "[IEEE802.3], 30.5.1.1.7, aMAUAdminState,
             30.5.1.2.2, acMAUAdminControl, and 30.5.1.2.1,
             acResetMAU."

        */
        attribute IfMauStatusType ifMauStatus;

        /*
             This object identifies Media Available state of
             the MAU, complementary to the ifMauStatus.  Values
             for the standard IEEE 802.3 Media Available states
             are defined in the IANA maintained IANA-MAU-MIB
             module, as IANAifMauMediaAvailable TC.
        REFERENCE:
            "[IEEE802.3], 30.5.1.1.4, aMediaAvailable."

        */
        readonly attribute IANAifMauMediaAvailableType ifMauMediaAvailable;

        /*
             A count of the number of times that
             ifMauMediaAvailable for this MAU instance leaves
             the state available(3).
             
             Discontinuities in the value of this counter can
             occur at re-initialization of the management
             system and at other times, as indicated by the
             value of ifCounterDiscontinuityTime.
        REFERENCE:
            "[IEEE802.3], 30.5.1.1.5, aLoseMediaCounter.
             RFC 2863, ifCounterDiscontinuityTime."

        */
        readonly attribute Counter32Type ifMauMediaAvailableStateExits;

        /*
             The value other(1) is returned if the jabber
             state is not 2, 3, or 4.  The agent MUST always
             return other(1) for MAU type dot3MauTypeAUI.
             
             The value unknown(2) is returned when the MAU's
             true state is unknown; for example, when it is
             being initialized.
             
             If the MAU is not jabbering the agent returns
             noJabber(3).  This is the 'normal' state.
             
             If the MAU is in jabber state the agent returns
             
             
             
             the jabbering(4) value.
        REFERENCE:
            "[IEEE802.3], 30.5.1.1.6, aJabber.jabberFlag."

        */
        readonly attribute IfMauJabberStateType ifMauJabberState;

        /*
             A count of the number of times that
             mauJabberState for this MAU instance enters the
             state jabbering(4).  This counter will always
             indicate zero for MAUs of type dot3MauTypeAUI
             and those of speeds above 10Mbps.
             
             Discontinuities in the value of this counter can
             occur at re-initialization of the management
             system and at other times, as indicated by the
             value of ifCounterDiscontinuityTime.
        REFERENCE:
            "[IEEE802.3], 30.5.1.1.6, aJabber.jabberCounter.
             RFC 2863, ifCounterDiscontinuityTime."

        */
        readonly attribute Counter32Type ifMauJabberingStateEnters;

        /*
             A count of the number of false carrier events
             during IDLE in 100BASE-X and 1000BASE-X links.
             
             For all other MAU types, this counter will
             always indicate zero.  This counter does not
             increment at the symbol rate.
             
             It can increment after a valid carrier
             completion at a maximum rate of once per 100 ms
             for 100BASE-X and once per 10us for 1000BASE-X
             until the next CarrierEvent.
             
             This counter can roll over very quickly.  A
             management station is advised to poll the
             ifMauHCFalseCarriers instead of this counter in
             order to avoid loss of information.
             
             Discontinuities in the value of this counter can
             occur at re-initialization of the management
             system and at other times, as indicated by the
             value of ifCounterDiscontinuityTime.
        REFERENCE:
            "[IEEE802.3], 30.5.1.1.10, aFalseCarriers.
             
             
             
             RFC 2863, ifCounterDiscontinuityTime."

        */
        readonly attribute Counter32Type ifMauFalseCarriers;

        /*
             This object identifies the default
             administrative baseband MAU type to be used in
             conjunction with the operational MAU type
             denoted by ifMauType.
             
             The set of possible values for this object is
             the same as the set defined for the ifMauType
             object.
             
             This object represents the
             administratively-configured type of the MAU.  If
             auto-negotiation is not enabled or is not
             implemented for this MAU, the value of this
             object determines the operational type of the
             MAU.  In this case, a set to this object will
             force the MAU into the specified operating mode.
             
             If auto-negotiation is implemented and enabled
             for this MAU, the operational type of the MAU
             is determined by auto-negotiation, and the value
             of this object denotes the type to which the MAU
             will automatically revert if/when
             auto-negotiation is later disabled.
             
             NOTE TO IMPLEMENTORS:  It may be necessary to
             provide for underlying hardware implementations
             which do not follow the exact behavior specified
             above.  In particular, when
             ifMauAutoNegAdminStatus transitions from enabled
             to disabled, the agent implementation MUST
             ensure that the operational type of the MAU (as
             reported by ifMauType) correctly transitions to
             the value specified by this object, rather than
             continuing to operate at the value earlier
             determined by the auto-negotiation function.
        REFERENCE:
            "[IEEE802.3], 30.5.1.1.1, aMAUID, and 22.2.4.1.4."

        */
        attribute AutonomousTypeType ifMauDefaultType;

        /*
             This object indicates whether or not
             auto-negotiation is supported on this MAU.
        */
        readonly attribute TruthValueType ifMauAutoNegSupported;

        /*
             A value that uniquely identifies the set of
             possible IEEE 802.3 types that the MAU could be.
             If auto-negotiation is present on this MAU, this
             object will map to ifMauAutoNegCapabilityBits.
             
             Note that this MAU may be capable of operating
             as a MAU type that is beyond the scope of this
             MIB.  This is indicated by returning the
             bit value bOther in addition to any bit values
             for standard capabilities that are listed in the
             IANAifMauTypeListBits TC.
        */
        readonly attribute IANAifMauTypeListBitsType ifMauTypeListBits;

        /*
             A count of the number of false carrier events
             during IDLE in 100BASE-X and 1000BASE-X links.
             
             For all other MAU types, this counter will
             always indicate zero.  This counter does not
             increment at the symbol rate.
             
             This counter is a 64-bit version of
             ifMauFalseCarriers.  Since the 32-bit version of
             this counter can roll over very quickly,
             management stations are advised to poll the
             64-bit version instead, in order to avoid loss
             of information.
             
             Discontinuities in the value of this counter can
             occur at re-initialization of the management
             system and at other times, as indicated by the
             value of ifCounterDiscontinuityTime.
        REFERENCE:
            "[IEEE802.3], 30.5.1.1.10, aFalseCarriers.
             
             
             
             RFC 2863, ifCounterDiscontinuityTime."

        */
        readonly attribute Counter64Type ifMauHCFalseCarriers;
    };


    /*
             An entry in the table, containing information
             about a particular jack.
    */
    interface ifJackEntry : SNMPMgmt::SmiEntry {

        const string IndexVarList = "ifMauIfIndex ifMauIndex ifJackIndex";

        /*
             The jack connector type, as it appears on the
             outside of the system.
        */
        readonly attribute IANAifJackTypeType ifJackType;
    };

    interface dot3IfMauAutoNegGroup : SNMPMgmt::SmiEntry {

        /*
             Configuration and status objects for the
             auto-negotiation function of MAUs attached to
             interfaces.
             
             The ifMauAutoNegTable applies to systems in
             which auto-negotiation is supported on one or
             more MAUs attached to interfaces.  Note that if
             auto-negotiation is present and enabled, the
             ifMauType object reflects the result of the
             auto-negotiation function.
        */
        SNMPMgmt::SmiTableIterator get_ifMauAutoNegTable();
    };


    /*
             An entry in the table, containing configuration
             and status information for the auto-negotiation
             function of a particular MAU.
    */
    interface ifMauAutoNegEntry : SNMPMgmt::SmiEntry {

        const string IndexVarList = "ifMauIfIndex ifMauIndex";

        /*
             Setting this object to enabled(1) will cause
             the interface that has the auto-negotiation
             signaling ability to be enabled.
             
             If the value of this object is disabled(2) then
             the interface will act as it would if it had no
             auto-negotiation signaling.  Under these
             conditions, an IEEE 802.3 MAU will immediately
             be forced to the state indicated by the value of
             the object ifMauDefaultType.
             
             NOTE TO IMPLEMENTORS:  When
             ifMauAutoNegAdminStatus transitions from enabled
             to disabled, the agent implementation MUST
             ensure that the operational type of the MAU (as
             reported by ifMauType) correctly transitions to
             the value specified by the ifMauDefaultType
             object, rather than continuing to operate at the
             value earlier determined by the auto-negotiation
             function.
        REFERENCE:
            "[IEEE802.3], 30.6.1.1.2, aAutoNegAdminState,
             and 30.6.1.2.2, acAutoNegAdminControl."

        */
        attribute IfMauAutoNegAdminStatusType ifMauAutoNegAdminStatus;

        /*
             A value indicating whether the remote end of
             the link is using auto-negotiation signaling.  It
             takes the value detected(1) if and only if,
             during the previous link negotiation, FLP Bursts
             were received.
        REFERENCE:
            "[IEEE802.3], 30.6.1.1.3,
             aAutoNegRemoteSignaling."

        */
        readonly attribute IfMauAutoNegRemoteSignalingType ifMauAutoNegRemoteSignaling;

        /*
             A value indicating the current status of the
             auto-negotiation process.  The enumeration
             parallelDetectFail(5) maps to a failure in
             parallel detection as defined in 28.2.3.1 of
             [IEEE802.3].
        REFERENCE:
            "[IEEE802.3], 30.6.1.1.4, aAutoNegAutoConfig."

        */
        readonly attribute IfMauAutoNegConfigType ifMauAutoNegConfig;

        /*
             If the value of this object is set to
             restart(1) then this will force auto-negotiation
             to begin link renegotiation.  If auto-negotiation
             signaling is disabled, a write to this object
             has no effect.
             Setting the value of this object to norestart(2)
             has no effect.
        REFERENCE:
            "[IEEE802.3], 30.6.1.2.1,
             acAutoNegRestartAutoConfig."

        */
        attribute IfMauAutoNegRestartType ifMauAutoNegRestart;

        /*
             A value that uniquely identifies the set of
             capabilities of the local auto-negotiation
             entity.  Note that interfaces that support this
             MIB may have capabilities that extend beyond the
             scope of this MIB.
             
             Note that the local auto-negotiation entity may
             support some capabilities beyond the scope of
             this MIB.  This is indicated by returning the
             bit value bOther in addition to any bit values
             for standard capabilities that are listed in the
             IANAifMauAutoNegCapBits TC.
        REFERENCE:
            "[IEEE802.3], 30.6.1.1.5,
             aAutoNegLocalTechnologyAbility."

        */
        readonly attribute IANAifMauAutoNegCapBitsType ifMauAutoNegCapabilityBits;

        /*
             A value that uniquely identifies the set of
             capabilities advertised by the local
             auto-negotiation entity.
             
             Capabilities in this object that are not
             available in ifMauAutoNegCapabilityBits cannot
             be enabled.
             
             Note that the local auto-negotiation entity may
             advertise some capabilities beyond the scope of
             this MIB.  This is indicated by returning the
             bit value bOther in addition to any bit values
             for standard capabilities that are listed in the
             IANAifMauAutoNegCapBits TC.
        REFERENCE:
            "[IEEE802.3], 30.6.1.1.6,
             aAutoNegAdvertisedTechnologyAbility."

        */
        attribute IANAifMauAutoNegCapBitsType ifMauAutoNegCapAdvertisedBits;

        /*
             A value that uniquely identifies the set of
             capabilities received from the remote
             auto-negotiation entity.
             Note that interfaces that support this MIB may
             be attached to remote auto-negotiation entities
             that have capabilities beyond the scope of this
             MIB.  This is indicated by returning the bit
             value bOther in addition to any bit values for
             standard capabilities that are listed in the
             IANAifMauAutoNegCapBits TC.
        REFERENCE:
            "[IEEE802.3], 30.6.1.1.7,
             aAutoNegReceivedTechnologyAbility."

        */
        readonly attribute IANAifMauAutoNegCapBitsType ifMauAutoNegCapReceivedBits;

        /*
             A value that identifies any local fault
             indications that this MAU has detected and will
             advertise at the next auto-negotiation
             interaction for 1000Mbps MAUs.
        REFERENCE:
            "[IEEE802.3], 30.6.1.1.6,
             aAutoNegAdvertisedTechnologyAbility."

        */
        attribute IfMauAutoNegRemoteFaultAdvertisedType ifMauAutoNegRemoteFaultAdvertised;

        /*
             A value that identifies any fault indications
             received from the far end of a link by the
             local auto-negotiation entity for 1000Mbps
             MAUs.
        REFERENCE:
            "[IEEE802.3], 30.6.1.1.7,
             aAutoNegReceivedTechnologyAbility."

        */
        readonly attribute IfMauAutoNegRemoteFaultReceivedType ifMauAutoNegRemoteFaultReceived;
    };

    struct RpMauJabberStateVBType {
        string var_name;
        string var_index;
        RpMauJabberStateType rpMauJabberState;
    };

    struct IfMauJabberStateVBType {
        string var_name;
        string var_index;
        IfMauJabberStateType ifMauJabberState;
    };

    struct RpMauJabberTrapType {
        RpMauJabberStateVBType rpMauJabberState;
    };

    struct IfMauJabberTrapType {
        IfMauJabberStateVBType ifMauJabberState;
    };

    /* typed push event communication */
    interface Notifications : SNMPMgmt::Notifications {

        /*
             This trap is sent whenever a managed repeater
             MAU enters the jabber state.
             
             The agent MUST throttle the generation of
             consecutive rpMauJabberTraps so that there is at
             least a five-second gap between them.
        REFERENCE:
            "[IEEE802.3], 30.5.1.3.1, nJabber notification."

        */
        void rpMauJabberTrap (
            in CosNaming::Name src_entry_name,
            in CORBA::ScopedName event_type,
            in ASN1_GeneralizedTime event_time,
            in RpMauJabberTrapType notification_info
        );

        /*
             This trap is sent whenever a managed interface
             MAU enters the jabber state.
             
             The agent MUST throttle the generation of
             consecutive ifMauJabberTraps so that there is at
             least a five-second gap between them.
        REFERENCE:
            "[IEEE802.3], 30.5.1.3.1, nJabber notification."

        */
        void ifMauJabberTrap (
            in CosNaming::Name src_entry_name,
            in CORBA::ScopedName event_type,
            in ASN1_GeneralizedTime event_time,
            in IfMauJabberTrapType notification_info
        );
    };

    /* typed pull event communication */
    interface PullNotifications : SNMPMgmt::PullNotifications {

        /*
             This trap is sent whenever a managed repeater
             MAU enters the jabber state.
             
             The agent MUST throttle the generation of
             consecutive rpMauJabberTraps so that there is at
             least a five-second gap between them.
        REFERENCE:
            "[IEEE802.3], 30.5.1.3.1, nJabber notification."

        */
        void pull_rpMauJabberTrap (
            out CosNaming::Name src_entry_name,
            out CORBA::ScopedName event_type,
            out ASN1_GeneralizedTime event_time,
            out RpMauJabberTrapType notification_info
        );
        boolean try_rpMauJabberTrap (
            out CosNaming::Name src_entry_name,
            out CORBA::ScopedName event_type,
            out ASN1_GeneralizedTime event_time,
            out RpMauJabberTrapType notification_info
        );

        /*
             This trap is sent whenever a managed interface
             MAU enters the jabber state.
             
             The agent MUST throttle the generation of
             consecutive ifMauJabberTraps so that there is at
             least a five-second gap between them.
        REFERENCE:
            "[IEEE802.3], 30.5.1.3.1, nJabber notification."

        */
        void pull_ifMauJabberTrap (
            out CosNaming::Name src_entry_name,
            out CORBA::ScopedName event_type,
            out ASN1_GeneralizedTime event_time,
            out IfMauJabberTrapType notification_info
        );
        boolean try_ifMauJabberTrap (
            out CosNaming::Name src_entry_name,
            out CORBA::ScopedName event_type,
            out ASN1_GeneralizedTime event_time,
            out IfMauJabberTrapType notification_info
        );
    };

    interface SmiEntryFactory : SNMPMgmt::GenericFactory {

        rpMauEntry create_rpMauEntry (
            in RpMauGroupIndexType rpMauGroupIndex,
            in RpMauPortIndexType rpMauPortIndex,
            in RpMauIndexType rpMauIndex,
            in RpMauStatusType rpMauStatus
        ) raises (
            SNMPMgmt::AlreadyExists,
            CosLifeCycle::InvalidCriteria,
            CosLifeCycle::CannotMeetCriteria
        );

        ifMauEntry create_ifMauEntry (
            in InterfaceIndexType ifMauIfIndex,
            in IfMauIndexType ifMauIndex,
            in IfMauStatusType ifMauStatus,
            in AutonomousTypeType ifMauDefaultType
        ) raises (
            SNMPMgmt::AlreadyExists,
            CosLifeCycle::InvalidCriteria,
            CosLifeCycle::CannotMeetCriteria
        );

        ifMauAutoNegEntry create_ifMauAutoNegEntry (
            in InterfaceIndexType ifMauIfIndex,
            in IfMauIndexType ifMauIndex,
            in IfMauAutoNegAdminStatusType ifMauAutoNegAdminStatus,
            in IfMauAutoNegRestartType ifMauAutoNegRestart,
            in IANAifMauAutoNegCapBitsType ifMauAutoNegCapAdvertisedBits,
            in IfMauAutoNegRemoteFaultAdvertisedType ifMauAutoNegRemoteFaultAdvertised
        ) raises (
            SNMPMgmt::AlreadyExists,
            CosLifeCycle::InvalidCriteria,
            CosLifeCycle::CannotMeetCriteria
        );
    };

};

#endif /* !_MAU_MIB_IDL_ */
